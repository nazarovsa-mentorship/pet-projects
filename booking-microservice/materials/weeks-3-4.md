# Недели 3 - 4: Создание API и абстракций бизнес-логики приложения

# Цель

- Познакомить с слоёной архитектурой
- Сформировать понимание DI
- Сформировать навыки:
  - Реализации API слоя приложения
  - Реализации абстракций сервисного слоя приложения
  - Обработки исключений по формату Problem Details в ASP.NET приложениях

# Слоёная архитектура приложения

**Слоёная архитектура** - это архитектура приложения, которая подразумеввает разделения кодовой базы на слои с конкретной ответсвенностью. Выделяют слои:  
- **Presentation Layer**- Слой взаимодействия с пользователем или внешними системами. Это API в случае backend-приложения.
- **Business Layer**- Слой бизнес-логики. На нем выполняется обработка входящих запросов согласно бизнес-правилам.
- **Persistence Layer** - Слой хранения данных. На нем данные подготовленные слоем бизнес-логики сохраняются в хранилище данных.

**Основное преимущество:** слои позволяют структурировать код, что приводит к разделению ответсвенности и упрощает поддержку кода.

С недостатками и деталями ознакомься в статье - [Слоистая архитектура приложений: как обеспечить поддерживаемость доменного слоя](https://habr.com/ru/articles/802617/)

# HTTP методы

О методах можешь прочитать тут:  
[Методы HTTP запроса](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods)

Тебя интересуют основные методы, которые ты будешь использовать в контроллерах:
- GET
- POST
- PUT/PATCH
- DELETE
  
## GET

Семантически используется для получения данных.  
Не поддерживает body. Как правило используется для методов, возвращающих данные по Id.  
Метод не поддерживает body, поэтому для передачи аргументов ты можешь использовать путь и query string, который [имеет ограничение по длине](https://stackoverflow.com/a/417184/14095048). Поэтому когда нужно сделать выборку с множеством параметров, их объединяют в один тип и используют в body с методом POST, это не совсем канонично, но позволяет обойти ограничение.

## POST

Семантически используется для запросов изменяющих состояние системы. Чаще всего для методов, которые создают новые сущности.

## PUT/PATCH

Семантически используются для запросов обновляющих данные в системе. Например, обновление сущности.  
Какой метод выбрать? Зависит от проекта и мировоззрения твоих коллег.  
Я привык считать, что PUT - это метод семантики `CreateOrUpdate`, а PATCH - `Update`. Но повторюсь, во много мзависит от проекта. В последнее время я всегда использую PUT для запросов обновляющих данные в системе.

## DELETE

Семантически используется для запросов удаления сущностей в системе.

# API: Body-запросы и ответы

## Запросы

Как я упомянул выше, данные запроса могут быть оформлены в виде объекта, переданного в body. Для этого мы создаем отдельный тип в C# с постфикстом `Request`. Это может быть `class` или `record`. Если на проекте используется CQRS, то постфиксы будут `Command` или `Query`. Можешь почитать про [CQRS](https://microservices.io/patterns/data/cqrs.html) для интереса. В нашем проекте мы не будем его реализовывать.

Например, тебе нужно описать запрос создания пользователя. В качестве аргументов у тебя email, ФИО и дата рождения. Тогда, ты создаешь следующий тип: 

```csharp
public record CreateUserRequest(string Email, string Fullname, DateOnly BirthDate);
```

Далее, ты используешь его в методе контроллера POST с байндингом `[FromBody]`. Постфикс важен, для того, чтобы разделять типы API и бизнес логики.

## Ответы

С ответами аналогичная ситуация.  
Для ответа используются типы с постфиксом `Response` и `Data` или `Dto`. Во втором случае я предпочитаю `Data`.  

Важно разделять `Response` и `Data/Dto`. Когда я проверял работы учеников в корпоративной школе, практически каждый не понимал разницы.

### Data

**Data** - это транспортный тип, отражающий модель бизнес логики.

Например, у тебя есть сущность `User`, внутри нее есть логика, и тебе не хочется оперировать ей на уровне контрактов. Нужно, чтобы модель транспортного уровня была максимально простой. Тогда ты делаешь в контрактной сборке тип `UserData` и переносишь туда нужны для ответа поля. Важно понимать, что модель транспортного уровня может содержать не все данные домена. То есть, если в `User` есть поля, которые не нужны потребителям API, их не нужно включать в `UserData`.

```csharp
// Доменная сборка
public class User {

    public long Id { get; set; }

    public string Email { get; set; }

    public string Fullname { get; set; }

    public DateOnly BirthDate { get; set; }

    // Остальные свойства и методы
}

// Сборка контрактов
public record UserData(long Id, string Email, string Fullname, DateOnly BirthDate);
```

### Response

**Response** - это ответ на конкретный запрос. Он может содержать множество полей типа `Data`. Например, на запрос получения списка всех пользователей можно ответить массивом `Data` и тогда семантика метода будет следующей:

```csharp
pulic Task<UserData[]> GetAllUsers();
```

Но можно и `Response'ом`. Тогда метод будет таким: 
```csharp
pulic Task<GetAllUsersResponse> GetAllUsers();
```

А тип `GetAllUsersResponse` будет следующим:

```csharp
public record GetAllUsersResponse(UserData[] users);
```

Я отдаю предпочтения варианту с `Data`, там где это возможно. Обычно `Response` используется, когда нужно вернуть что-то не отражающее доменную сущность или набор разных данных `Data`.

# Контроллеры

Контроллер - это точка входа в наш API. Он может содержать методы. Старайся минимизировать логику внутри контроллера, в идеале свести ее к вызову соответсвующегно метода сервиса.

[Metanit: Создание контроллера](https://metanit.com/sharp/aspnet5/23.2.php)  
[Parameter Binding in ASP.NET Web API](https://learn.microsoft.com/en-us/aspnet/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api)

# Сервисы

**Сервис** - это тип, обслуживающий интеграционные взаимодействия API с бизнес-логикой приложения. В рамках сервиса выполняется предобработка входящих данных и передача их в бизнес-логику.  
Сервис содержит методы для создания и изменения сущностей и возврата данных по идентификатору. 

Забежим немного в перед и обратимся к концепции репозитория. [Репозиторий](https://metanit.com/sharp/articles/mvc/11.php) - это паттерн работы с данными. Он предоставляет методы по семантики CRUD (Create - Read - Update - Delete). То есть, как правило репозиторий содержит методы `Create`, `Update`, `GetById` и `Delete`. Иногда включают метод получения списка сущностей `Get`. Но я считаю, что такому методу место в Queries, о которых мы поговорим далее. Важно отметить, что метод репозитория `GetById` должен полностью загрузить сущность со всеми зависимостями, что неприемлемо, скажем, когда нужно получить одно поле.

Так вот, в сервис ты внедряешь репозиторий и можешь вызывать только его CRUD методы. Ты ограничен ими. Но при этом ты можешь получить, создать, обновить и удалить сущность. Этого достаточно, чтобы совершить любые изменения. Поэтому у нас остается пласт запросов к БД, которые не ложатся в концепт репозитория. Например, получит список пользователей по фильтру или статус сущности по идентификатору.  

Почему бы не добавить другие методы в репозиторий? 
Потому что тогда пострадает код: будет нарушен принцип единственной ответсвенности, потому что репозиторий должен обслуживать CRUD операции. И тут мы переходим к Queries.

# Queries: Отличия от сервисов

**Queries или запросы** - это обращения на чтение, которые не могут быть обслужены методами репозитория. Возьмем пример выше - получение списка пользователей по фильтру. Для таких запросов мы делаем отдельную абстракцию и в реализации используем прямой доступ к данным. Например, `DbContext` для EntityFramework. Это позволяет писать более гибкие запросы к системе хранения данных без лишнего оверхеда. Например, нам не нужно загружать всю сущность из БД только для того, чтобы получить ее статус. Мы просто достаем статус, тем самым снижая нагрузку и увеличивая время выполнения.

# Dependency Injection

**Внедрение зависимостей (Dependency injection)** - это паттерн, который позволяет реализовать принцип [Dependency Inversion](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#dependency-inversion) из SOLID между классами и их зависимостями. Основной принцип - **использовать в качестве зависимостей интерфейсы, а их реализации регистрировать в DI**.

## Материалы для самостоятельного изучения

[.NET dependency injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)

# Формат Problem Details и библиотека Hellang.Middleware.ProblemDetails

Формат Problem Details используется для унификации ответов от сервера в случае возникновения ошибки. Подробнее о формате ты можешь прочитать [здесь](https://nordicapis.com/a-look-at-problem-details-for-http-apis-rfc/).  
В нашем приложении нужно будет выполнить маппинг исключений на коды ответа HTTP. Вот как это можно сделать.

Для работы подключения мы будем использовать nuget-пакет `Hellang.Middleware.ProblemDetails`.  
Например, чтобы выполнить маппинг исключения типа `Exception` на код `402` можно добавить следующий код в методы `ConfigureServices` и `Configure` класса `Startup.cs`.

```csharp

public void ConfigureServices(IServiceCollection services)
{
    services.AddProblemDetails(options =>
    {
        // Если окружение Development, включаем подробное описание ошибки в ответ.
        options.IncludeExceptionDetails = (context, _) =>
        {
            var env = context.RequestServices.GetRequiredService<IWebHostEnvironment>();
            return env.IsDevelopment();
        };

        options.Map<Exception>(ex => new ProblemDetails
        {
            Status = 402,
            Type = $"https://httpstatuses.com/{402}",
            Title = "Something went wrong",
            Detail = ex.Message
        });
    });
}

public void Configure(IApplicationBuiler app)
{
    app.UseProblemDetails();
}
```
