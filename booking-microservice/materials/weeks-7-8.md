# Недели 7 - 8: Создание слоя взаимодействия с БД; Библиотека EntityFramework Core

# Цель

Сформировать понимание:
- Назначение паттерна Repository 
- Назначение паттерна Unit of Work

Сформировать навыки:
- Запуск PostgreSQL в docker-compose
- Написание маппинга классов бизнес-логики на БД для EntityFramework Core
- Использование миграций EntityFramework Core
- Реализация сервисного слоя приложения

# База даных и системы управления базами данных

**База данных** — это упорядоченный набор структурированной информации или данных, которые обычно хранятся в электронном виде в компьютерной системе. База данных обычно управляется системой управления базами данных (СУБД). Данные вместе с СУБД, а также приложения, которые с ними связаны, называются системой баз данных, или, для краткости, просто базой данных.

# БД в docker-compose

Для корректной работы приложения понадобится запущенный экземпляр БД. Ты будешь использовать PostgreSQL.  
Удобнее всего запустить базу данных в docker-compose. Рассмотрим секцию конфигуарции на примере конфигурации БД для сервиса catalog

```yml
# Имя сервиса в docker-compose
booking-service_catalog-db:
  # Образ
  image: postgres:latest
  # Имя контейнера
  container_name: catalog-db
  # Маппинг портов контейнера на корневую операционную систему. Слева порт ОС, справа порт контейнера.
  ports:
    # Порт 5432 контейнера будет доступен на порту 5432 ОС
    - "5432:5432"
  # Переменные окружения контейнера
  environment:
    # Имя БД
    POSTGRES_DB: "booking_service_catalog"
    # Имя пользователя
    POSTGRES_USER: "catalog_admin"
    # Пароль пользователя
    POSTGRES_PASSWORD: "admin_catalog"
    # Путь к каталогу в контейнере, в котором будут храниться файлы базы данных
    PGDATA: /data/postgres/
  # Проверка готовности СУБД принимать входящие подключения. Нужна для создания зависимостей с другими контейнерами.
  healthcheck:
    test: /usr/bin/pg_isready
    interval: 5s
    timeout: 10s
    retries: 5
```

# EntityFramework Core

`EntityFramework Core` - это библиотека, предоставляющая функциональность ORM (Object-Relational Mapper) для взаимодействия с БД.

ORM озволяет разработчикам работать с БД, используя знакомые объектно-ориентированные подходы вместо того, чтобы писать sql запросы. 

Преимущества использования ORM:
- Упрощает процесс разработки и снижает количество ошибок при разработке кода для взаимодействия с БД
- Упрощает поддержку кода взаимодействия с БД
- Повышает производительность приложения за счет предоставления таких инструментов как кэширование, ленивая загрузка данных и пул соединений
- Предоставляет уровень абстракции между приложением и базой данных, что позволяет изолировать код приложения от изменений схемы базы данных
- Предоставляет возможность сменить провайдер базы данных без внесения значительных изменений в кодовую базу

Возможности EntityFramework Core:
- **Кросс-платформенность**: EF Core может быть использован на различных платформах, включая Windows, Linux и Mac
- **Легковесность**: EF Core занимает меньше места и содержит меньше зависимостей по сравнению с полной версией Entity Framework
- **Code first**: EF Core предоставляет разработчикам вохможность создавать базу данных на основании кода
- **Поддержка LINQ**: EF Core поддерживает Linq
- **Поддержка различных СУБД:** EF Core поддерживает популярные СУБД, включая SQL Server, MySQL, PostgreSQL и SQLite
- **Поддержка миграций**: EF Core имеет встроенную поддержку создания и управления миграциями базы данных
- **Поддержка отношений сущностей**: EF Core поддерживает отношения один-к-одному, один-ко-многим и многие-ко-многим
- Поддержка вычисления на клиенте и ленивой загрузки (lazy loaded)
- Поддержка отслеживания изменений (Change tracking) и кэширования 

## Отслеживание изменений (Change Tracking)

EntityFramework Core поддерживает механизм отслеживания изменений. Это значит, что все изменения сущности выполняются в памяти до момента, пока не будет вызван метод `SaveChanges` или `SaveChangesAsync`. Это позволяет снизить нагрузку на БД за счет того, что все изменения сущностей в рамках выполнения бизнес операции выполняются единомоментно.

Подробнее с принципом работы следует ознакомиться в 3 главе книги Днон П. Смит - EntityFramework в действии.

## Маппинг объектов на БД

Для маппинга объектов бизнес-логики на БД можно использовать два подхода: аттрибуты и FluentApi.

Атрибуты нужно проставлять в классе, который будет отображен в БД. Так как сущности в нашем сервисе являются агрегатами и располагаются в сборке `Domain` мы не будем использовать атрибуты, чтобы не добавлять лишних зависимостей.

Подход FluentApi позволяет сконфигурировать маппинг в сборке, содержащей DbContext. Для описания агрегата ты будешь использовать класс реализующий интерфейс `IEntityTypeConfiguration<T>`, где `T` описываемый класс.

Для примера возьмем упрощенный класс самолета из предыдущих недель:
```csharp
public class Plane

  public long Id { get; get; }

  public string AircraftNumber { get; get; }

  public long PilotId { get; set; }

  public int MaxSeatsCount { get; get; }

  public bool FlightStarted { get; set; }
}
```

Для того, чтобы выполнить маппинг на БД создадим следующий класс
```csharp
public class PlaneConfiguration : IEntityTypeConfiguration<Plane>
{
    public void Configure(EntityTypeBuilder<BookingAggregate> builder)
    {
        // Указываем целевое имя таблицы
        builder.ToTable("planes");

        // Указываем, что первичным ключом является поле id
        builder.HasKey(x => x.Id)
            // Указываем имя ключа
            .HasName("pk_planes");

        // Конфигурируем свойство самолета Id
        builder.Property(x => x.Id)
            // Указываем имя колонки в БД
            .HasColumnName("id");

        builder.Property(x => x.AircraftNumber)
            // Указываем имя колонки в БД
            .HasColumnName("aircraft_number")
            // Указываем максимальную длинну строкового значения колонки
            .HasMaxLength(7)
            // Указываем что колонка обязательна к заполнению. Колонки значимых типов обязательны по умолчанию.
            .IsRequired();

        builder.Property(x => x.PilotId)
            // Указываем имя колонки в БД
            .HasColumnName("pilot_id");

        builder.Property(x => x.MaxSeatsCount)
            // Указываем имя колонки в БД
            .HasColumnName("max_seats_count");

        builder.Property(x => x.FlightStarted)
            // Указываем имя колонки в БД
            .HasColumnName("flight_started");
    }
}
```

В классе описаны правила маппинга объекта на БД. В примере использована лишь малая часть возможностей, но для выполнения практической части тебе будет достаточно изучить их.   
Так как мы используем PostgreSQL, нейминги объектов БД и колонок должны быть в snake_case.

## Миграции

Миграции БД - это инструмент обновления структуры базы данных.  
В каждой миграции содержится инкремент изменений, которые необходимо применить к БД.

Для того, чтобы работать с миграциями Entity Framework существует dotnet tool утилита, которая называется dotnet-ef. Он устанавливается на компьютер и позволяет выполнять команды для управленими миграциями и обновления БД.

Для того, чтобы установить утилиту необходимо выполнить команду:  
`dotnet tool install -g dotnet-ef`

Преимущества:
- Возможность использования средств автоматизации для обновления БД
- Наличие актуального контекста БД на момент последней примененной миграции в файле `DbContextModelSnapshot`
- Возможность развернуть базу данных с нуля до консистентного состояния или конкретной миграции 

### Создание миграций

Для создания миграций применяется команда `dotnet ef migrations add "НАЗВАНИЕ_МИГРАЦИИ"`. Запускать ее нужно в проекте, содержащем DbContext.
При запуске команды выполняется сборка проекта и проверка изменений структуры БД.  
При создании первой миграции в папке `Migrations` создается класс `DbContextModelSnapshot`, в котором хранится состояние БД на момент последней созданной миграции. При каждом вызове команды на создание миграции dotnet-ef анализирует контекст на наличие изменений по сравнению с снапшотом:
- Если изменения структуры есть, создается класс новой миграция c изменениями. 
- Если изменений нет, то будет создан класс миграции с пустыми методами на изменения. Это может быть полезно, если ты хочешь выполнить кастомную миграцию не на основе DbContext.

Обрати внимание на имя миграции после создания. Оно имеет следующий формат  
`yyyyMMddHHmmss_Название_миграции`

Дата добавляется в начало для поддержания историчности. При применении миграций к БД, они будут выполняться от старых к новым. 

Все изменения должны вноситься в БД с помощью новых миграций, так как изменение старых или добавление миграции с датой меньше последней, могут привести к неконсистентному состоянию БД. 

### Применение миграций

Для того, чтобы применить миграции к БД существует команда `dotnet ef database update`.  
При первом запуске помимо выполнения миграций в БД создается таблица истории миграций  `__EFMigrationsHistory`. В нее вносятся все примененные миграции. Это делается для того, чтобы в момент обновления БД применять к ней только новые миграции.  
При последующих запусках выполняется применение только новых миграций и добавление записей о них в `__EFMigrationsHistory`.

Структура таблицы истории миграций
```sql 
create table "__EFMigrationsHistory"
(
    "MigrationId"    varchar(150) not null constraint "PK___EFMigrationsHistory" primary key,
    "ProductVersion" varchar(32)  not null
);
```

`MigrationId` - это название миграции.

## DesignTimeDbContextFactory

Во время работы с EntityFramework тебе понадобится сконфигурировать DbContext. В ASP.NET приложении это делается с помощью регистрации необходимых зависимостей в DI. Но при запуске миграций этот способ не работает.  
Для того, чтобы сконфигурировать контекст во время миграции следует использовать интерфейс `IDesignTimeDbContextFactory<T>`, где `T` - тип контекста.  
С помощью метода `CreateDbContext` можно указать тип провайдера БД, строку подключения и другие параметры контекста.  
В нашем проекте мы будем использовать следующий код, извлекающий строку подключения из файла `appsettings.json`

`DesignTimeDbContextFactory.cs`:
```csharp
public class DesignTimeDbContextFactory : IDesignTimeDbContextFactory<BookingsContext>
{
    public BookingsContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<BookingsContext>();

        var configuration = new ConfigurationBuilder()
            .SetBasePath(AppDomain.CurrentDomain.BaseDirectory)
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .Build();

        var connectionString = configuration.GetConnectionString(nameof(BookingsContext));
        if (string.IsNullOrWhiteSpace(connectionString))
            throw new InvalidOperationException($"ConnectionString for `{nameof(BookingsContext)}` not found");

        optionsBuilder.UseNpgsql(connectionString);

        return new BookingsContext(optionsBuilder.Options);
    }
}
```

Этот код создает конфигурацию и подключает в нее файл `appsettings.json`. После чего извлекает строку подключения из файла с помощью метода `GetConnectionString`.

# Паттерн Repository

Паттерн Repository представляет собой абстракцию для доступа к данным. Он позволяет отделить бизнес-логику от кода доступа к данным, предоставляя интерфейс, похожий на коллекцию, для работы с сущностями предметной области.

Основные преимущества использования паттерна Repository:
- Централизованное управление данными и логикой доступа к ним
- Минимизация дублирования кода для доступа к данным
- Повышение тестируемости кода за счет возможности подмены репозитория на его мок при тестировании
- Изоляция бизнес-логики от деталей доступа к данным
- Упрощение кода бизнес-логики и повышение его читаемости

В нашем приложении мы будем использовать репозиторий для работы с агрегатом `BookingAggregate`. Репозиторий будет предоставлять методы для создания, получения и обновления бронирований.

# Паттерн Unit of Work

Паттерн Unit of Work (Единица работы) - это паттерн, который позволяет группировать операции над данными в одну атомарную операцию. Он обеспечивает поддержку транзакций при работе с базой данных.

Основные преимущества использования паттерна Unit of Work:
- Обеспечение атомарности операций (все операции в рамках единицы работы либо выполняются успешно, либо не выполняются вообще)
- Повышение производительности за счет уменьшения количества обращений к БД (все изменения отправляются в БД одним запросом)
- Упрощение управления транзакциями
- Повышение уровня абстракции кода

В нашем приложении мы будем использовать Unit of Work для координации работы репозиториев и управления транзакциями. Unit of Work будет содержать ссылку на репозиторий бронирований и метод для фиксации изменений в БД.

# Реализация сервисного слоя приложения

Сервисный слой приложения содержит бизнес-логику и координирует работу между контроллерами API и доменной моделью. Он отвечает за выполнение операций над доменными объектами и сохранение изменений в БД.

В нашем приложении сервисный слой будет представлен классами `BookingsService` и `BookingsQueries`.

## Реализация обработчиков, изменяющих состояние объекта

`BookingsService` отвечает за выполнение операций, которые изменяют состояние бронирований. Класс будет использовать `IUnitOfWork` и его `IBookingsRepository` для загрузки, изменения и сохранения агрегата `BookingAggregate`.

Типичный процесс обработки команды в `BookingsService` будет выглядеть следующим образом:
1. Получение агрегата из репозитория по идентификатору
2. Выполнение операции над агрегатом (вызов метода бизнес-логики)
3. Обновление агрегата в репозитории
4. Фиксация изменений с помощью Unit of Work

## Реализация обработчиков, возвращающих данные

`BookingsQueries` отвечает за выполнение запросов к БД для получения данных. Класс будет использовать `BookingsContext` для выполнения запросов к БД с использованием LINQ.

Класс `BookingsQueries` должен эффективно выполнять запросы к БД, выбирая только необходимые данные и применяя фильтрацию на уровне БД, а не в памяти приложения. При наличии условий фильтрации запрос к БД должен дополняться соответствующими предикатами.

##  Материалы для изучения

[Oracle: Что такое база данных?](https://www.oracle.com/cis/database/what-is-database/)  
Днон П. Смит - EntityFramework в действии: главы 1 - 11  
[Metanit: Управление схемой БД и миграции](https://metanit.com/sharp/entityframeworkcore/2.15.php)  
[Learn EntityFramework Core](https://www.learnentityframeworkcore.com/)  
[Learn EntityFramework Core: EF Core Migrations](https://www.learnentityframeworkcore.com/migrations)  
[ConfigurationExtensions.GetConnectionString(IConfiguration, String) Method](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationextensions.getconnectionstring?view=net-8.0)