# Итерация 6: Асинхронное межсервисное взаимодействие

# Цель

Сформировать понимание:
- Преимущества и недостатки асинхронных взаимодействий

Сформировать наывыки:
- Использование библиотеки Rebus для взаимодействия с другим сервисом через RabbitMQ

# Асинхронное межсервисное взаимодействие

**Асинхронное взаимодействие** - это взаимодействие между компонентами системы, которое не подразумевает мгновенный ответ. Например, публикация события в брокер сообщений.

Асинхронные взаимодействия почти всегда используют дополнительный компонент системы, называющийся брокером сообщений. Брокер сообщений обеспечивает возможность доставки этих сообщений между микросервисами. Наиболее популярными брокерами являются RabbitMQ и Kafka.

Отказ от синхронных взаимодействий между компонентами системы в пользу асинхронных позволяет добиться снижения связанности компонентов и повышения отказоустойчивости всей системы.

Асинхронные взаимодействия между компонентами системы, используются для обмена сообщениями об уже совершившихся действиях (обмен событиями) и для инициирования бизнес-процессов (отправка команды). 

**Сообщение** - информация передаваемая асинхронно.  
**Событие** - сообщение о совершившемся действии.  
**Команда** - сообщение с намерением внести изменения в систему.

## Отправка пользователю email-подтверждения после создания

Представим бизнес-процесс, когда после создания пользователя ему приходит письмо с подтверждением на почту. 
Можно описать его так:
1. Создать пользователя
2. Отправить сообщение на email с ссылкой активации
3. Подтвердить активацию по ссылке

Рассмотрим шаги 1 и 2 и кейс, когда есть микросервис пользователей и микросервис отправки email.  
Пример синхронного взаимодействия:

```mermaid
stateDiagram-v2
    user: Пользователь
    users: Микросервис пользователей
    email: Микросервис email
    user --> users : HTTP POST - Зарегистрироваться
    users --> email : HTTP POST - Отправить email
```
Пользователь нажимает кнопку "Зарегистрироваться" в web-приложении, которое отправляет запрос на создание пользователя. Микросервис пользователей в логике обработки запроса синхронно вызывает микросервис email. Так как все взаимодействия синхронные, при возникновении ошибки при отправки email, запрос на создание пользователя не будет выполнен. 

Описанная схема имеет высокую связанность сервисов и низкую отказоустойчивость. 

### События

**События используются для уведомлении о совершившемся изменении состояния системы.**

Бизнес выпустил новые требования: пользователи должны создаваться даже если микросервис email недоступен.

Можно отправить событие о том, что пользователь создан (UserCreated) и обработать его в микросервисе email. При этом микросервис породивший событие может даже не знать о том, что оно будет обработано.

Вот как можно выполнить это требование с использованием асинхронных взаимодействий.
```mermaid
stateDiagram-v2
    user: Пользователь
    users: Микросервис пользователей
    email: Микросервис email
    bus: Брокер сообщений
    user --> users : HTTP POST - Зарегистрироваться
    users --> bus: UserCreated - Пользователь создан
    bus --> email : UserCreated - Пользователь создан
```

В схему добавился еще один компонент: брокер сообщений. Он позволяет отвязать логику взаимодействия создания пользователя от взаимодействия с сервисом email.

Пользователь нажимает кнопку "Зарегистрироваться" в web-приложении, которое отправляет запрос на создание пользователя. Микросервис пользователей создает в своей БД пользователя и отправляет в брокер событие о новом пользователе. Брокер доставляет событие до сервиса email, который отправляет письмо пользователю. При этом если сервис email недоступен, не блокируется процесс создания пользователя. Рано или поздно сервис email обработает события и отправит письма. Это называется Eventual Consistency.

Описанная схема имеет меньшую связность и более высокую отказоустойчивость по сравнению с первой.

### Команды

**Команды используются для запуска действия, выполнение которого изменит состояние системы.**

Пример, когда микросервис email подписывается на событие UserCreated, не оптимален с точки зрения того, что событием UserCreated владеет микросервис пользователей. При таком подходе придется менять код микросервиса email и подписываться на другие события, если нужно будет отправлять email от других микросервисов. Этот сценарий не лучший, так как сервис email должен быть универсальным. Назовем его сервисом общего пользования. 

Сейчас с точки зрения распространения контрактов и зависимостей схема выглядит так:
```mermaid
stateDiagram-v2
    users: Сервис пользователей
    email: Сервис email
    service_1: Микросервис 1
    service_2: Микросервис 2
    service_n: Микросервис n
    email --> users: Зависит от контракта UsersCreated
    email --> service_1: Зависит от контракта Event1
    email --> service_2: Зависит от контракта Event2
    email --> service_n: Зависит от контракта Event3
```

Для того, чтобы микросервис email не зависел от других и действительно стал сервисом общего пользователя можно можно создать команду (SendEmailCommand) в микросервисе email. Тогда для отправки письма микросервис, которому нужно выполнить это действие будет публиковать команду в брокер сообщений, а микросервис email будет обрабатывать ее и не зависеть от других сервисов.

```mermaid
stateDiagram-v2
    users: Сервис пользователей
    email: Сервис email
    service_1: Микросервис 1
    service_2: Микросервис 2
    service_n: Микросервис n
    users --> email: Зависит от SendEmailCommand
    service_1 --> email:  Зависит от SendEmailCommand
    service_2 --> email:  Зависит от SendEmailCommand
    service_n --> email:  Зависит от SendEmailCommand
```

# Rebus

**Rebus** - это библиотека, которая используется для реализации асинхронных взаимодействий. Она предоставляет абстракции, которые позволяют взаимодействовать с различными брокерами в единой манере. 

Для того, чтобы подключить Rebus в свое приложение нужно выполнить следующие шаги:
1. Добавить в свой проект nuget-пакеты
   - Rebus
   - Rebus.ServiceProvider
   - Rebus.Serilog
   - Rebus.RabbitMq в нашем случае или пакет для интеграции с другим брокером сообщений 
2. Подключить Rebus в хосте своего приложения. Далее представлен пример конфигурации Rebus для RabbitMQ. Например, в методе `ConfigureServices` класса `Startup`
```csharp
// Добавляем зависимости Rebus в DI
services.AddRebus((builder, ctx) =>
// Выбираем транспорт
  builder.Transport(t =>
    // Используем в качестве транспорта RabbitMQ: указываем строку подключение + имя очереди, которую будет слушать приложение
    t.UseRabbitMq("amqp://admin:admin@localhost:5672/", "domain-service-queue")
      // Указываем, что нужно хранить сообщения в очереди персистентно через вызов SetDurable(true)
      .DefaultQueueOptions(queue => queue.SetDurable(true))
      // Указываем имена exchange для очереди выше: direct exchange, на который будет подписана очередь сервиса и topics exchange, который будет выступать хабом для обмена сообщениями
      .ExchangeNames("domain-service-direct", "domain-topics"))
    // Указываем, какую сериализацию использовать
    .Serialization(s => s.UseSystemTextJson())
    // Указыаем, какое логирование использовать
    .Logging(l => l.Serilog())
    // Указываем, что роутинг нужно осуществлять по имени типа
    // В таком случае для события будет использован строку формата "namespace + короткое имя типа, namespace" в качестве ключа маршрутизации 
    .Routing(r => r.TypeBased()));
```
И подписаться на необходимые события. Для этого необходимо получить из собранного DI-контейнера экземпляр `IBus` и вызвать метод `Subscribe`. Например, в методе `Configure` класса `Startup`
```csharp
app.ApplicationServices.GetRequiredService<IBus>().Subscribe<EventType>();
```

Код выше сделает следующее:
- Создаст, если еще не создана, очередь `domain-service-queue` и будет слушать ее: `t.UseRabbitMq("amqp://admin:admin@localhost:5672/", "domain-service-queue")`
- Создаст, если еще не созданы, direct exchange `domain-service-direct` и topics exchange `domain-topics`: `ExchangeNames("domain-service-direct", "domain-topics")`
- Подпишет очередь `domain-service-queue` на `domain-topics` с ключом маршрутизации для EventType: `app.ApplicationServices.GetRequiredService<IBus>().Subscribe<EventType>();`. Допустим TypeBased ключ для EventType - `MyNamespace.EventType, MyNamespace`, это значит, что все события опубликованные с этим ключом в exchange `domain-topics` будут доставлены до сервиса
  Будет публиковать события сервиса в exchange `domain-topics` с TypeBased ключами маршрутизации при вызове метода `IBus.Send`.

# RabbitMQ

**RabbitMQ** - это брокер сообщений, реализующий push-модель. 

Подробнее об архитектуре можно почитать [здесь](https://habr.com/ru/companies/slurm/articles/684412/)